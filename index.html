—É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è.</span>
            </button>
            
            <button class="mode-selection-button" data-mode="ai_only">
                **–ò–ò –ø—Ä–æ—Ç–∏–≤ –ò–ò** ‚öîÔ∏è
                <br><span style="font-size: 0.8em;
color: inherit;">–ù–∞–±–ª—é–¥–∞–π—Ç–µ, –∫–∞–∫ –ò–ò –∏–≥—Ä–∞–µ—Ç —Å–∞–º —Å —Å–æ–±–æ–π. –°—á–µ—Ç –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è.</span>
            </button>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="settings">&times;</span>
            <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ò–≥—Ä—ã</h2>
            <hr style="border-color: #ccc; margin-bottom: 20px;">
            
            <button id="theme-toggle-button" class="game-button" style="width: 100%; margin-bottom: 15px; background-image: linear-gradient(to right, #795548 0%, #A1887F 100%);">
                –°–º–µ–Ω–∏—Ç—å –¢–µ–º—É (–¢–µ–∫—É—â–∞—è: –°–≤–µ—Ç–ª–∞—è)
            </button>

            <p style="font-size: 1.1em; font-weight: 500; color: #ff6b6b; margin-bottom: 10px;">
                **–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –ò–ò**
            </p>
            <div style="display: flex; justify-content: space-around; gap: 10px;">
                <button class="mode-selection-button active" data-difficulty="1" style="flex-grow: 1;">–£—Ä–æ–≤–µ–Ω—å 1 (–ë—ã—Å—Ç—Ä–æ)</button>
                <button class="mode-selection-button" data-difficulty="3" style="flex-grow: 1;">–£—Ä–æ–≤–µ–Ω—å 2 (–°—Ä–µ–¥–Ω–µ)</button>
                <button class="mode-selection-button" data-difficulty="5" style="flex-grow: 1;">–£—Ä–æ–≤–µ–Ω—å 3 (–ú–µ–¥–ª–µ–Ω–Ω–æ)</button>
            </div>
            
        </div>
    </div>
    
    <div id="auth-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="auth">&times;</span>
            <h2>–í—Ö–æ–¥ –∏–ª–∏ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</h2>
            <hr style="border-color: #ccc; margin-bottom: 20px;">
            
            <form id="auth-form" style="text-align: center;">
                <input type="email" id="auth-email" placeholder="Email" required style="width: 100%; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #ccc; box-sizing: border-box; color: #333;">
                <input type="password" id="auth-password" placeholder="–ü–∞—Ä–æ–ª—å" required style="width: 100%; padding: 10px; margin-bottom: 15px; border-radius: 5px; border: 1px solid #ccc; box-sizing: border-box; color: #333;">
                
                <p id="auth-message" style="margin-bottom: 10px; font-weight: 600; color: #e74c3c; min-height: 1.1em;"></p>
                
                <button type="submit" id="auth-submit" class="game-button" style="width: 100%; background-image: linear-gradient(to right, #6c5ce7 0%, #a29bfe 100%);">–í–æ–π—Ç–∏</button>
                <button type="button" id="toggle-register-button" class="game-button" style="width: 100%; margin-top: 5px; background-image: linear-gradient(to right, #2ecc71 0%, #27ae60 100%);">–°–æ–∑–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç</button>
            </form>
            
        </div>
    </div>
    
    <div id="leaderboard-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="leaderboard">&times;</span>
            <h2>–¢–∞–±–ª–∏—Ü–∞ –õ–∏–¥–µ—Ä–æ–≤</h2>
            <hr style="border-color: #ccc; margin-bottom: 20px;">
            
            <ul id="leaderboard-list">
                
            </ul>
        </div>
    </div>
    
    <div id="profile-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="profile">&times;</span>
            <h2 id="profile-nickname">–ü—Ä–æ—Ñ–∏–ª—å –ò–≥—Ä–æ–∫–∞</h2>
            <hr style="border-color: #ccc; margin-bottom: 20px;">
            
            <img id="profile-avatar" src="" alt="–ê–≤–∞—Ç–∞—Ä">
            
            <div id="profile-stats" style="text-align: center;">
                <p>–í—ã—Å—à–∏–π –°—á–µ—Ç: <strong id="profile-high-score">0</strong></p>
                <p>–°—ã–≥—Ä–∞–Ω–æ –ò–≥—Ä: <strong id="profile-games-played">0</strong></p>
            </div>
            
            <form id="edit-profile-form" style="display: none; margin-top: 15px;">
                <label for="edit-nickname-input" style="font-weight: 600; display: block; margin-top: 15px; margin-bottom: 5px;">–ù–æ–≤—ã–π –Ω–∏–∫–Ω–µ–π–º:</label>
                <input type="text" id="edit-nickname-input" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º" required minlength="3">
                <button type="submit" class="game-button" style="width: 100%; background-image: linear-gradient(to right, #4CAF50 0%, #8BC34A 100%);">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                <button type="button" id="cancel-edit-button" class="game-button" style="width: 100%; margin-top: 5px; background-image: linear-gradient(to right, #e74c3c 0%, #c0392b 100%);">–û—Ç–º–µ–Ω–∞</button>
            </form>
            
            <button type="button" id="edit-profile-button" class="game-button" style="width: 100%; display: none;">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å</button>
            <p id="profile-message" style="margin-top: 15px; font-weight: 600; color: #e74c3c; min-height: 1.1em; text-align: center;"></p>
        </div>
    </div>
    
    <div class="sanwec-credit">
        –†–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–æ —Å –ª—é–±–æ–≤—å—é @sanwec | 2024
    </div>

    
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-firestore.js"></script>
    
    <script>
        
        const firebaseConfig = {
            apiKey: "...",
            authDomain: "...",
            projectId: "...",
            storageBucket: "...",
            messagingSenderId: "...",
            appId: "..."
        };

        
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        } else {
            firebase.app(); 
        }
        
        const auth = firebase.auth();
        const db = firebase.firestore();

        
        const BOARD_SIZE = 8;
        const EMPTY_COLOR = 'transparent'; 
        const NORMAL_MODE = 'normal';
        const TRAINING_MODE = 'training';
        const AI_ONLY_MODE = 'ai_only';
        
        let board = []; 
        let score = 0;
        let gameMode = NORMAL_MODE;
        let comboCounter = 0;
        let currentShapes = []; 
        let draggedShapeIndex = -1;
        let dragOffset = {row: 0, col: 0};
        let currentUser = null; 
        let currentProfileUserId = null; 
        let isRegistering = false; 
        let isEditProfile = false; 
        let aiDifficulty = 1; 
        let gameLoopInterval; 
        
        
        let gameBoardStateHash = '';
        let scoreStateHash = '';
        
        
        let currentBestPlacements = []; 
        let lastHighlightedCells = []; 
        
        
        const gameBoardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const comboDisplayElement = document.getElementById('combo-display');
        const nextBlocksElement = document.getElementById('next-blocks');
        const resetButton = document.getElementById('reset-button');
        const modeButton = document.getElementById('mode-button');
        const settingsButton = document.getElementById('settings-button');
        const authButton = document.getElementById('auth-button');
        const leaderboardButton = document.getElementById('leaderboard-button');
        const modeInfoElement = document.getElementById('mode-info');

        
        const modeModal = document.getElementById('mode-modal');
        const settingsModal = document.getElementById('settings-modal');
        const authModal = document.getElementById('auth-modal');
        const leaderboardModal = document.getElementById('leaderboard-modal');
        const profileModal = document.getElementById('profile-modal');
        
        const closeButtons = document.querySelectorAll('.close-button');
        const modeSelectionButtons = document.querySelectorAll('.mode-selection-button[data-mode]');
        
        
        const authForm = document.getElementById('auth-form');
        const authMessage = document.getElementById('auth-message');
        const toggleRegisterButton = document.getElementById('toggle-register-button');
        
        
        const profileNicknameElement = document.getElementById('profile-nickname');
        const profileHighScoreElement = document.getElementById('profile-high-score');
        const profileGamesPlayedElement = document.getElementById('profile-games-played');
        const editProfileButton = document.getElementById('edit-profile-button');
        const editProfileForm = document.getElementById('edit-profile-form');
        const editNicknameInput = document.getElementById('edit-nickname-input');
        const cancelEditButton = document.getElementById('cancel-edit-button');
        const profileMessage = document.getElementById('profile-message');
        const profileAvatar = document.getElementById('profile-avatar');
        
        
        const difficultyButtons = document.querySelectorAll('.mode-selection-button[data-difficulty]');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        
        
        const leaderboardList = document.getElementById('leaderboard-list');

        
        const SHAPES = [
            
            { size: 1, color: '#ff6b6b', pattern: [[1]] },
            
            { size: 2, color: '#feca57', pattern: [[1,1]] },
            { size: 2, color: '#feca57', pattern: [[1],[1]] },
            
            { size: 4, color: '#54a0ff', pattern: [[1,1],[1,1]] },
            { size: 3, color: '#1dd1a1', pattern: [[1,1,1]] },
            { size: 3, color: '#1dd1a1', pattern: [[1],[1],[1]] },
            
            { size: 4, color: '#a29bfe', pattern: [[1,1,1,1]] },
            { size: 4, color: '#a29bfe', pattern: [[1],[1],[1],[1]] },
            
            { size: 3, color: '#ff9f43', pattern: [[1,0],[1,0],[1,1]] }, 
            { size: 3, color: '#ff9f43', pattern: [[1,1,1],[1,0,0]] }, 
            
            { size: 4, color: '#ff7675', pattern: [[0,1,0],[1,1,1],[0,0,0]] }, 
            
            { size: 5, color: '#ffb8b8', pattern: [[1,1,0],[0,1,0],[0,1,1]] },
            
            { size: 4, color: '#fd79a8', pattern: [[1,1,0],[0,1,1]] },
            
            { size: 4, color: '#2d3436', pattern: [[1,1],[0,1],[0,1]] }
        ];

        
        function generateBoard() {
            board = [];
            gameBoardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                board[r] = [];
                for (let c = 0; c < BOARD_SIZE; c++) {
                    board[r][c] = EMPTY_COLOR;
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gameBoardElement.appendChild(cell);
                }
            }
        }

        function canPlaceShape(pattern, startR, startC) {
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        const boardR = startR + r;
                        const boardC = startC + c;

                        
                        if (boardR < 0 || boardR >= BOARD_SIZE || boardC < 0 || boardC >= BOARD_SIZE) {
                            return false;
                        }
                        
                        if (board[boardR][boardC] !== EMPTY_COLOR) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeShape(shapeData, startR, startC) {
            const pattern = shapeData.pattern;
            const color = shapeData.color;
            let cellsAffected = 0; 

            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        const boardR = startR + r;
                        const boardC = startC + c;

                        board[boardR][boardC] = color;
                        const cell = gameBoardElement.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                        if (cell) {
                            cell.classList.add('filled');
                            cell.style.backgroundColor = color;
                            cellsAffected++;
                        }
                    }
                }
            }
            
            updateScore(cellsAffected, false, 0); 
            
            protectGameVariables();
        }

        function clearLines(cellsToClear) {
            if (cellsToClear.size === 0) {
                return;
            }

            
            cellsToClear.forEach(key => {
                const [r, c] = key.split('-').map(Number);
                const cell = gameBoardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cell) {
                    cell.classList.add('clearing');
                }
            });

            
            setTimeout(() => {
                cellsToClear.forEach(key => {
                    const [r, c] = key.split('-').map(Number);
                    const cell = gameBoardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.remove('filled', 'clearing');
                        cell.style.backgroundColor = EMPTY_COLOR;
                        cell.style.opacity = '1';
                    }
                    board[r][c] = EMPTY_COLOR;
                });
                
                protectGameVariables();
            }, 400); 
        }

        function checkAndClearLines() {
            let clearedLines = 0;
            const cellsToClear = new Set(); 

            
            for (let r = 0; r < BOARD_SIZE; r++) {
                let isRowFull = true;
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === EMPTY_COLOR) {
                        isRowFull = false;
                        break;
                    }
                }
                if (isRowFull) {
                    clearedLines++;
                    for (let c = 0; c < BOARD_SIZE; c++) cellsToClear.add(`${r}-${c}`);
                }
            }

            
            for (let c = 0; c < BOARD_SIZE; c++) {
                let isColFull = true;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    if (board[r][c] === EMPTY_COLOR) {
                        isColFull = false;
                        break;
                    }
                }
                if (isColFull) {
                    clearedLines++;
                    for(let r = 0; r < BOARD_SIZE; r++) cellsToClear.add(`${r}-${c}`);
                }
            }

            if (clearedLines > 0) {
                clearLines(cellsToClear);
                updateScore(clearedLines * BOARD_SIZE, false, clearedLines); 
            }
        }

        function showCombo(count, reset = false) {
            if (reset || count <= 1) {
                comboDisplayElement.textContent = '';
                comboDisplayElement.style.opacity = '0';
                return;
            }
            
            comboDisplayElement.textContent = `üî• –ö–û–ú–ë–û x${count}!`;
            comboDisplayElement.style.opacity = '1';
            
            comboDisplayElement.style.fontSize = `${1.1 + count * 0.1}em`;
            comboDisplayElement.style.color = count >= 3 ? '#ff4757' : '#e67e22'; 
        }

        function updateScore(points, reset = false, linesCleared = 0) {
            if (reset) {
                score = points;
                comboCounter = 0;
                showCombo(0, true);
            } else {
                if (!validateGameVariables()) return; 
                let baseScore = points;
                
                
                if (linesCleared > 0) {
                    comboCounter++;
                    baseScore += (comboCounter - 1) * 10; 
                } else {
                    comboCounter = 0; 
                }
                
                showCombo(comboCounter);
                score += baseScore;
            }

            scoreElement.textContent = score;
        }

        function generateNextShapes() {
            if (!validateGameVariables()) return; 

            nextBlocksElement.innerHTML = '';
            
            
            const remainingShapes = currentShapes.filter(s => s !== null);
            if (remainingShapes.length === 0) {
                currentShapes = [];
                for (let i = 0; i < 3; i++) {
                    const randomIndex = Math.floor(Math.random() * SHAPES.length);
                    currentShapes.push(SHAPES[randomIndex]);
                }
            }
            
            
            currentBestPlacements = [];
            for (let i = 0; i < 3; i++) {
                const shapeData = currentShapes[i];
                if (shapeData) {
                    const container = createShapeElement(shapeData, i);
                    nextBlocksElement.appendChild(container);
                    currentBestPlacements.push(findBestPlacement(shapeData));
                } else {
                    currentBestPlacements.push(null);
                }
            }

            
            if (gameMode === TRAINING_MODE) {
                showAllAIHighlights();
            }

            
            if (currentShapes.filter(s => s !== null).every((shape, index) => currentBestPlacements[index] === null)) {
                gameOver();
            }
            
            
            protectGameVariables();
        }

        function createShapeElement(shapeData, index) {
            const container = document.createElement('div');
            container.classList.add('shape-container');
            container.setAttribute('draggable', 'true'); 
            container.dataset.shapeIndex = index;

            const shapeDiv = document.createElement('div');
            shapeDiv.classList.add('shape');
            shapeDiv.style.gridTemplateColumns = `repeat(${shapeData.pattern[0].length}, 1fr)`;
            
            for (let r = 0; r < shapeData.pattern.length; r++) {
                for (let c = 0; c < shapeData.pattern[0].length; c++) {
                    if (shapeData.pattern[r][c] === 1) {
                        const block = document.createElement('div');
                        block.classList.add('block');
                        block.style.backgroundColor = shapeData.color;
                        block.dataset.row = r; 
                        block.dataset.col = c; 
                        shapeDiv.appendChild(block);
                    } else {
                         
                        const emptyBlock = document.createElement('div');
                        emptyBlock.style.width = '22px';
                        emptyBlock.style.height = '22px';
                        shapeDiv.appendChild(emptyBlock);
                    }
                }
            }
            
            container.appendChild(shapeDiv);
            
            
            container.ondragstart = handleDragStart;
            container.ondragend = handleDragEnd;
            
            container.onmousedown = handleMouseDown;
            container.ontouchstart = handleTouchStart;

            return container;
        }

        function gameOver() {
            
            if (gameMode === NORMAL_MODE && currentUser) {
                updateHighScore(score);
            }
            
            
            setTimeout(() => {
                alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í–∞—à —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å—á–µ—Ç: ${score}`);
                initializeGame(gameMode); 
            }, 500); 
        }
        
        function isGameOver() {
            
             if (currentShapes.filter(s => s !== null).every((shape, index) => currentBestPlacements[index] === null)) {
                gameOver();
            }
        }

        function initializeGame(mode) {
            if (!validateGameVariables()) return; 
            
            
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            
            generateBoard();
            updateScore(0, true);
            currentShapes = []; 
            currentBestPlacements = [];
            gameMode = mode;
            clearHighlight();
            
            
            modeInfoElement.textContent = 
                mode === NORMAL_MODE ? '–û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º.' :
                mode === TRAINING_MODE ? '–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ —Å –ò–ò-–ø–æ–¥—Å–∫–∞–∑—á–∏–∫–æ–º.' :
                '–ò–ò –ø—Ä–æ—Ç–∏–≤ –ò–ò.';
            
            
            document.getElementById('reset-button').style.display = 'block';
            
            if (gameMode === AI_ONLY_MODE) {
                 document.getElementById('reset-button').style.display = 'none';
                 
                 runAIGameLoop();
            } else {
                 generateNextShapes();
            }
            
            
            modeSelectionButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === gameMode) {
                    btn.classList.add('active');
                }
            });
            
            
            protectGameVariables(); 
        }
        
        
        
        function hashBoard(board) {
            let hash = '';
            for(let r = 0; r < BOARD_SIZE; r++) {
                hash += board[r].join('');
            }
            
            let charCodeSum = 0;
            for(let i = 0; i < hash.length; i++) {
                charCodeSum = (charCodeSum + hash.charCodeAt(i)) % 1000003; 
            }
            return charCodeSum.toString(16) + score.toString(16);
        }

        function protectGameVariables() {
            gameBoardStateHash = hashBoard(board);
            scoreStateHash = score.toString(16);
        }

        function validateGameVariables() {
            const currentBoardHash = hashBoard(board);
            const currentScoreHash = score.toString(16);

            if (currentBoardHash !== gameBoardStateHash || currentScoreHash !== scoreStateHash) {
                blockUser('–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –ø–æ–ø—ã—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è. –í–∞—à —Å—á–µ—Ç –Ω–µ –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω.');
                return false;
            }
            return true;
        }

        function blockUser(reason = '–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –ø–æ–ø—ã—Ç–∫–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –∫–æ–Ω—Å–æ–ª—å—é –∏–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∏–≥—Ä—ã.') {
            const gameContainer = document.querySelector('.game-container');
            
            gameContainer.style.pointerEvents = 'none';
            gameContainer.style.opacity = '0.1';

            
            document.body.innerHTML = `
                <div style="text-align: center; color: #ff6b6b; padding: 50px; background-color: #ffffff; border-radius: 15px; box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);">
                    <h2>‚õî –ë–õ–û–ö–ò–†–û–í–ö–ê –ò–ì–†–´</h2>
                    <p style="font-size: 1.1em;">${reason}</p>
                    <p>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.</p>
                </div>
            `;
            
            if (gameLoopInterval) clearInterval(gameLoopInterval);
        }

        
        
        function getShapeOffset(shapeElement, shapePattern, event) {
            const shapeBlocks = shapeElement.querySelectorAll('.block');
            let offsetX = 0;
            let offsetY = 0;
            
            
            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

            
            let closestBlock = null;
            let minDistance = Infinity;

            for (const block of shapeBlocks) {
                const rect = block.getBoundingClientRect();
                const dist = Math.sqrt(
                    Math.pow(clientX - (rect.left + rect.width / 2), 2) +
                    Math.pow(clientY - (rect.top + rect.height / 2), 2)
                );

                if (dist < minDistance) {
                    minDistance = dist;
                    closestBlock = block;
                }
            }

            if (closestBlock) {
                dragOffset.row = parseInt(closestBlock.dataset.row);
                dragOffset.col = parseInt(closestBlock.dataset.col);
            } else {
                
                for (let r = 0; r < shapePattern.length; r++) {
                    for (let c = 0; c < shapePattern[0].length; c++) {
                        if (shapePattern[r][c] === 1) {
                            dragOffset.row = r;
                            dragOffset.col = c;
                            return;
                        }
                    }
                }
            }
        }
        
        function handleMouseDown(event) {
            const container = event.currentTarget;
            if (container.getAttribute('draggable') !== 'true') return;
            
            
            if (event.type.startsWith('touch')) {
                event.preventDefault();
            }

            
            const shapeIndex = parseInt(container.dataset.shapeIndex);
            draggedShapeIndex = shapeIndex;
            
            const shapeData = currentShapes[shapeIndex];
            if (!shapeData) return;
            
            getShapeOffset(container, shapeData.pattern, event);
            
            
            container.classList.add('is-dragging');
            
            
            document.onmousemove = handleMouseMove;
            document.onmouseup = handleMouseUp;

            
            clearHighlight();
        }
        
        
        function handleTouchStart(event) {
            handleMouseDown(event); 
            
            document.ontouchmove = handleTouchMove;
            document.ontouchend = handleTouchEnd;
        }

        function handleMouseMove(event) {
            event.preventDefault(); 
            if (draggedShapeIndex === -1) return;
            
            
            const targetCell = document.elementFromPoint(event.clientX, event.clientY);
            const boardCell = targetCell ? targetCell.closest('.cell') : null;
            
            if (boardCell) {
                handleDragOverInternal(boardCell);
            } else {
                clearPreview();
            }
        }
        
        function handleTouchMove(event) {
             if (draggedShapeIndex === -1) return;
             if (event.touches.length !== 1) return;
             
             
             const touch = event.touches[0];
             const targetCell = document.elementFromPoint(touch.clientX, touch.clientY);
             const boardCell = targetCell ? targetCell.closest('.cell') : null;
             
             if (boardCell) {
                 handleDragOverInternal(boardCell);
             } else {
                 clearPreview();
             }
        }
        
        function handleMouseUp(event) {
            if (draggedShapeIndex === -1) return;
            
            
            const targetCell = document.elementFromPoint(event.clientX, event.clientY);
            const boardCell = targetCell ? targetCell.closest('.cell') : null;
            
            if (boardCell) {
                handleDropInternal(boardCell);
            } else {
                
                handleDragEndInternal();
            }
            
            
            document.onmousemove = null;
            document.onmouseup = null;
        }
        
        function handleTouchEnd(event) {
            if (draggedShapeIndex === -1) return;
            
            
            const changedTouch = event.changedTouches[0];
            
            
            const targetCell = document.elementFromPoint(changedTouch.clientX, changedTouch.clientY);
            const boardCell = targetCell ? targetCell.closest('.cell') : null;
            
            if (boardCell) {
                handleDropInternal(boardCell);
            } else {
                
                handleDragEndInternal();
            }
            
            
            document.ontouchmove = null;
            document.ontouchend = null;
        }

        
        
        function handleDragStart(event) {
            
            event.dataTransfer.setData('text/plain', event.target.closest('.shape-container').dataset.shapeIndex);
            
            const shapeContainer = event.target.closest('.shape-container');
            const shapeIndex = parseInt(shapeContainer.dataset.shapeIndex);
            draggedShapeIndex = shapeIndex;
            
            const shapeData = currentShapes[shapeIndex];
            if (!shapeData) return;
            
            
            getShapeOffset(shapeContainer, shapeData.pattern, event);

            
            setTimeout(() => shapeContainer.classList.add('is-dragging'), 0);
            
            
            clearHighlight();
        }

        function handleDragEndInternal() {
            
            const container = document.querySelector(`.shape-container[data-shape-index="${draggedShapeIndex}"]`);
            if (container) {
                container.classList.remove('is-dragging');
            }
            clearPreview();
            draggedShapeIndex = -1;
            
            
            if (gameMode === TRAINING_MODE) {
                showAllAIHighlights();
            }
        }
        
        function handleDragEnd(event) {
             const shapeContainer = event.target.closest('.shape-container');
             
             shapeContainer.classList.remove('is-dragging');
             clearPreview();
             draggedShapeIndex = -1;
             
             
             if (gameMode === TRAINING_MODE) {
                showAllAIHighlights();
            }
        }

        function handleDragOverInternal(targetCell) {
            if (!targetCell || draggedShapeIndex === -1) return;
            const cellRow = parseInt(targetCell.dataset.row);
            const cellCol = parseInt(targetCell.dataset.col);
            
            
            const startRow = cellRow - dragOffset.row;
            const startCol = cellCol - dragOffset.col;
            
            const shapeData = currentShapes[draggedShapeIndex];
            if (!shapeData) return;
            
            previewPlacement(shapeData, startRow, startCol);
        }

        function handleDragOver(event) {
            event.preventDefault(); 
            const targetCell = event.target.closest('.cell');
            
            if (!targetCell || draggedShapeIndex === -1) return;
            handleDragOverInternal(targetCell);
        }

        function handleDragEnter(event) {
            event.preventDefault();
        }
        
        function handleDragLeave(event) {
            
            if (event.target.id === 'game-board' || event.target.closest('#game-board')) {
                 
                if (event.relatedTarget && !event.relatedTarget.closest('#game-board')) {
                    clearPreview();
                }
            }
        }

        function handleDropInternal(targetCell) {
            clearPreview(); 
            if (!targetCell || draggedShapeIndex === -1) {
                handleDragEndInternal();
                return;
            }

            const cellRow = parseInt(targetCell.dataset.row);
            const cellCol = parseInt(targetCell.dataset.col);
            
            
            const startRow = cellRow - dragOffset.row;
            const startCol = cellCol - dragOffset.col;
            
            const shapeIndex = draggedShapeIndex;
            const shapeData = currentShapes[shapeIndex];
            
            if (!shapeData) {
                handleDragEndInternal();
                return;
            }

            if (canPlaceShape(shapeData.pattern, startRow, startCol)) {
                placeShape(shapeData, startRow, startCol);
                currentShapes[shapeIndex] = null;

                
                const container = document.querySelector(`.shape-container[data-shape-index="${shapeIndex}"]`);
                if(container) container.remove();

                checkAndClearLines();
                
                if (currentShapes.every(s => s === null)) {
                    generateNextShapes();
                } else if (gameMode === TRAINING_MODE) {
                    
                    currentBestPlacements = currentShapes.map(s => s ? findBestPlacement(s) : null);
                    showAllAIHighlights();
                }

                isGameOver();
            } else {
                
                handleDragEndInternal();
            }
            
            draggedShapeIndex = -1;
        }

        function handleDrop(event) {
            event.preventDefault();
            clearPreview();
            
            const targetCell = event.target.closest('.cell');
            if (!targetCell) return;
            
            handleDropInternal(targetCell);
        }

        function previewPlacement(shapeData, startR, startC) {
            
            clearPreview();

            const pattern = shapeData.pattern;
            
            if (canPlaceShape(pattern, startR, startC)) {
                for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[0].length; c++) {
                        if (pattern[r][c] === 1) {
                            const boardR = startR + r;
                            const boardC = startC + c;

                            const cell = gameBoardElement.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                            if (cell) {
                                
                                cell.style.opacity = '0.5';
                                cell.style.backgroundColor = shapeData.color;
                                cell.classList.add('preview');
                            }
                        }
                    }
                }
            } else {
                 
                 for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[0].length; c++) {
                        if (pattern[r][c] === 1) {
                            const boardR = startR + r;
                            const boardC = startC + c;
                            
                            
                            if (boardR >= 0 && boardR < BOARD_SIZE && boardC >= 0 && boardC < BOARD_SIZE) {
                                const cell = gameBoardElement.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                                if (cell) {
                                    if (board[boardR][boardC] === EMPTY_COLOR) {
                                        cell.style.opacity = '0.3';
                                        cell.style.backgroundColor = 'red';
                                        cell.classList.add('preview');
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        function clearPreview() {
            gameBoardElement.querySelectorAll('.cell.preview').forEach(cell => {
                cell.style.opacity = '1';
                cell.style.backgroundColor = EMPTY_COLOR; 
                cell.classList.remove('preview');
            });
        }
        
        
        
        
        function evaluateBoard(board, clearedLines) {
            if (!validateGameVariables()) return -Infinity; 
            
            let score = 0;
            let occupiedCells = 0;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== EMPTY_COLOR) {
                        occupiedCells++;
                    }
                }
            }

            
            let potentialClears = 0;
            
            for (let r = 0; r < BOARD_SIZE; r++) {
                let filledInRow = 0;
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== EMPTY_COLOR) filledInRow++;
                }
                if (filledInRow === BOARD_SIZE - 1) {
                    potentialClears += 2; 
                } else if (filledInRow === BOARD_SIZE - 2) {
                    potentialClears += 1; 
                }
            }
            
            for (let c = 0; c < BOARD_SIZE; c++) {
                let filledInCol = 0;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    if (board[r][c] !== EMPTY_COLOR) filledInCol++;
                }
                if (filledInCol === BOARD_SIZE - 1) {
                    potentialClears += 2;
                } else if (filledInCol === BOARD_SIZE - 2) {
                    potentialClears += 1;
                }
            }

            
            score -= occupiedCells * 1; 

            
            
            if (clearedLines > 0) {
                score += clearedLines * BOARD_SIZE * Math.pow(1.5, clearedLines - 1) * 3;
            }
            
            
            score += potentialClears * 0.5;

            return score;
        }

        
        function simulatePlacement(board, shapeData, startR, startC) {
            const tempCells = JSON.parse(JSON.stringify(board)); 
            const pattern = shapeData.pattern;
            const color = shapeData.color;
            let cellsAffected = 0;

            if (!canPlaceShape(pattern, startR, startC)) {
                return { board: null, clearedLines: 0, scoreIncrease: 0 };
            }

            
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        tempCells[startR + r][startC + c] = color;
                        cellsAffected++;
                    }
                }
            }

            
            let clearedLines = 0;
            const cellsToClear = new Set();

            
            for (let r = 0; r < BOARD_SIZE; r++) {
                let isRowFull = true;
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (tempCells[r][c] === EMPTY_COLOR) {
                        isRowFull = false;
                        break;
                    }
                }
                if (isRowFull) {
                    clearedLines++;
                    for (let c = 0; c < BOARD_SIZE; c++) cellsToClear.add(`${r}-${c}`);
                }
            }

            
            for (let c = 0; c < BOARD_SIZE; c++) {
                let isColFull = true;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    if (tempCells[r][c] === EMPTY_COLOR) {
                        isColFull = false;
                        break;
                    }
                }
                if (isColFull) {
                    clearedLines++;
                    for(let r = 0; r < BOARD_SIZE; r++) cellsToClear.add(`${r}-${c}`);
                }
            }

            
            const nextBoard = JSON.parse(JSON.stringify(tempCells));
            if (clearedLines > 0) {
                cellsToClear.forEach(key => {
                    const [r, c] = key.split('-').map(Number);
                    nextBoard[r][c] = EMPTY_COLOR;
                });
            }

            
            const scoreIncrease = cellsAffected + (clearedLines > 0 ? clearedLines * BOARD_SIZE * clearedLines : 0);

            return { board: nextBoard, clearedLines: clearedLines, scoreIncrease: scoreIncrease };
        }


        
        function findBestPlacement(shapeData) {
            let bestScore = -Infinity;
            let bestPlacement = null;
            
            
            let maxDepth = aiDifficulty; 

            
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const result = simulatePlacement(board, shapeData, r, c);

                    if (result.board) {
                        
                        let currentScore = evaluateBoard(result.board, result.clearedLines) + result.scoreIncrease * 10;
                        
                        
                        if (maxDepth > 1) {
                            
                        }

                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            bestPlacement = { startR: r, startC: c };
                        }
                    }
                }
            }

            return bestPlacement; 
        }

        
        
        function clearHighlight() {
            lastHighlightedCells.forEach(cell => {
                cell.classList.remove('ai-highlight-0', 'ai-highlight-1', 'ai-highlight-2');
                cell.style.boxShadow = '';
                cell.style.border = '1px solid #b2bec3';
            });
            lastHighlightedCells = [];
            
            
            document.querySelectorAll('.shape-container').forEach(c => {
                 c.classList.remove('ai-target-0', 'ai-target-1', 'ai-target-2');
            });
        }
        
        function highlightAI(placement, shapeData, index) {
            clearHighlight();
            
            const startR = placement.startR;
            const startC = placement.startC;
            const pattern = shapeData.pattern;
            const colorClass = `ai-highlight-${index}`;
            const targetClass = `ai-target-${index}`;
            
            
            const shapeContainer = document.querySelector(`.shape-container[data-shape-index="${index}"]`);
            if (shapeContainer) {
                 shapeContainer.classList.add(targetClass);
            }

            
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        const boardR = startR + r;
                        const boardC = startC + c;
                        
                        const cell = gameBoardElement.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                        if (cell) {
                            cell.classList.add(colorClass);
                            lastHighlightedCells.push(cell);
                        }
                    }
                }
            }
        }
        
        function showAllAIHighlights() {
            clearHighlight(); 
            
            document.querySelectorAll('.shape-container').forEach(c => {
                 c.classList.remove('ai-target-0', 'ai-target-1', 'ai-target-2');
            });

            currentShapes.forEach((shapeData, index) => {
                if (shapeData === null) return;
                const placement = currentBestPlacements[index];
                if (placement) {
                    const startR = placement.startR;
                    const startC = placement.startC;
                    const pattern = shapeData.pattern;
                    const colorClass = `ai-highlight-${index}`;
                    const targetClass = `ai-target-${index}`;
                    
                    
                    const shapeContainer = document.querySelector(`.shape-container[data-shape-index="${index}"]`);
                    if (shapeContainer) {
                         shapeContainer.classList.add(targetClass);
                    }

                    
                    for (let r = 0; r < pattern.length; r++) {
                        for (let c = 0; c < pattern[0].length; c++) {
                            if (pattern[r][c] === 1) {
                                const boardR = startR + r;
                                const boardC = startC + c;
                                
                                const cell = gameBoardElement.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                                if (cell && board[boardR][boardC] === EMPTY_COLOR) { 
                                    cell.classList.add(colorClass);
                                    lastHighlightedCells.push(cell);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        
        
        function runAIGameLoop() {
            if (gameLoopInterval) clearInterval(gameLoopInterval);

            
            const delay = 1000 / aiDifficulty; 

            gameLoopInterval = setInterval(() => {
                if (gameMode !== AI_ONLY_MODE) {
                    clearInterval(gameLoopInterval);
                    return;
                }
                
                
                let overallBestScore = -Infinity;
                let bestMove = null; 
                
                
                if (currentShapes.every(s => s === null)) {
                    generateNextShapes();
                }

                currentShapes.forEach((shapeData, index) => {
                    if (shapeData === null) return;
                    const placement = currentBestPlacements[index]; 

                    if (placement) {
                        const result = simulatePlacement(board, shapeData, placement.startR, placement.startC);
                        
                        let currentScore = evaluateBoard(result.board, result.clearedLines) + result.scoreIncrease * 10;
                        
                        if (currentScore > overallBestScore) {
                            overallBestScore = currentScore;
                            bestMove = { shapeIndex: index, placement: placement, shapeData: shapeData };
                        }
                    }
                });
                
                
                if (bestMove) {
                    const { shapeIndex, placement, shapeData } = bestMove;
                    
                    
                    placeShape(shapeData, placement.startR, placement.startC);
                    currentShapes[shapeIndex] = null;
                    
                    
                    const container = document.querySelector(`.shape-container[data-shape-index="${shapeIndex}"]`);
                    if(container) container.remove();
                    
                    
                    checkAndClearLines();
                    
                    
                    if (currentShapes.every(s => s === null)) {
                        generateNextShapes();
                    } else {
                         
                        currentBestPlacements = currentShapes.map(s => s ? findBestPlacement(s) : null);
                        isGameOver();
                    }
                } else {
                    
                    gameOver();
                }

            }, delay);
        }

        
        
        
        auth.onAuthStateChanged(async (user) => {
            currentUser = user;
            if (user) {
                authButton.textContent = `–ü—Ä–æ—Ñ–∏–ª—å (${user.displayName || (user.email ? user.email.split('@')[0] : 'Anon')})`;
                await fetchProfile(user.uid); 
            } else {
                authButton.textContent = '–í—Ö–æ–¥/–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è';
            }
        });
        
        async function isNicknameUnique(nickname, currentUserId) {
             const snapshot = await db.collection("users").where("nickname", "==", nickname).get();
             if (snapshot.empty) {
                 return true;
             }
             
             const foundUserId = snapshot.docs[0].id;
             return foundUserId === currentUserId;
        }

        async function handleAuthSubmit(event) {
            event.preventDefault();
            authMessage.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞...';
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;

            try {
                if (isRegistering) {
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    const user = userCredential.user;
                    
                    
                    const defaultNickname = email.split('@')[0];
                    
                    let finalNickname = defaultNickname;
                    let suffix = 0;
                    while (!(await isNicknameUnique(finalNickname, user.uid))) {
                        suffix++;
                        finalNickname = defaultNickname + suffix;
                    }

                    
                    await user.updateProfile({ displayName: finalNickname });

                    
                    await db.collection("users").doc(user.uid).set({
                        email: email,
                        nickname: finalNickname,
                        highScore: 0,
                        gamesPlayed: 0
                    });

                    authMessage.textContent = '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞! –í—ã –≤–æ—à–ª–∏ –≤ —Å–∏—Å—Ç–µ–º—É.';
                } else {
                    await auth.signInWithEmailAndPassword(email, password);
                    authMessage.textContent = '–í—Ö–æ–¥ —É—Å–ø–µ—à–µ–Ω!';
                }
                
                
                setTimeout(() => authModal.style.display = 'none', 1000);
            } catch (error) {
                authMessage.textContent = `–û—à–∏–±–∫–∞: ${error.message}`;
                console.error("–û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏:", error);
            }
        }
        
        async function updateHighScore(newScore) {
            if (!currentUser || gameMode !== NORMAL_MODE) return; 

            const userRef = db.collection("users").doc(currentUser.uid);
            
            try {
                
                await db.runTransaction(async (transaction) => {
                    const userDoc = await transaction.get(userRef);

                    if (!userDoc.exists) {
                         
                         transaction.set(userRef, {
                            highScore: newScore,
                            gamesPlayed: 1 
                         });
                         return;
                    }
                    
                    const data = userDoc.data();
                    const oldHighScore = data.highScore || 0;
                    const newGamesPlayed = (data.gamesPlayed || 0) + 1;
                    
                    const updates = {
                        gamesPlayed: newGamesPlayed
                    };

                    if (newScore > oldHighScore) {
                        updates.highScore = newScore;
                    }
                    
                    transaction.update(userRef, updates);
                });
                
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–∫–æ—Ä–¥–∞/—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:", error);
            }
        }

        async function loadLeaderboard() {
            leaderboardList.innerHTML = '<li>–ó–∞–≥—Ä—É–∑–∫–∞...</li>';
            
            try {
                
                const snapshot = await db.collection("users")
                    .orderBy("highScore", "desc")
                    .limit(10)
                    .get();
                
                leaderboardList.innerHTML = ''; 
                let rank = 1;
                
                if (snapshot.empty) {
                    leaderboardList.innerHTML = '<li>–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ –ø—É—Å—Ç–∞. –ë—É–¥—å—Ç–µ –ø–µ—Ä–≤—ã–º!</li>';
                } else {
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const nickname = data.nickname || (data.email ? data.email.split('@')[0] : 'Anon');
                        const li = document.createElement('li');
                        li.innerHTML = `
                            <strong>#${rank}</strong> ${nickname}: <span>${data.highScore} –æ—á–∫–æ–≤</span>
                            <button class="game-button view-profile-button" data-user-id="${doc.id}" style="padding: 5px 10px; font-size: 0.8em; margin-left: 10px; background-image: linear-gradient(to right, #6c5ce7 0%, #a29bfe 100%);">–ü—Ä–æ—Ñ–∏–ª—å</button>
                        `;
                        leaderboardList.appendChild(li);
                        rank++;
                    });
                    
                    
                    document.querySelectorAll('.view-profile-button').forEach(button => {
                        button.onclick = (e) => {
                            e.stopPropagation(); 
                            const userId = e.target.dataset.userId;
                            leaderboardModal.style.display = 'none'; 
                            showProfileModal(userId); 
                        };
                    });
                }
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤:", error);
                leaderboardList.innerHTML = '<li>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏ –ø—Ä–∞–≤–∏–ª–∞ Firestore.</li>';
            }
        }
        
        async function fetchProfile(userId) {
            try {
                const doc = await db.collection("users").doc(userId).get();
                if (doc.exists) {
                    return doc.data();
                }
                return { nickname: 'Anon', highScore: 0, gamesPlayed: 0 };
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è:", error);
                return { nickname: 'Error', highScore: 0, gamesPlayed: 0 };
            }
        }

        async function showProfileModal(userId) {
            currentProfileUserId = userId;
            const profileData = await fetchProfile(userId);
            
            const nickname = profileData.nickname || (profileData.email ? profileData.email.split('@')[0] : 'Anon');
            
            profileNicknameElement.textContent = `–ü—Ä–æ—Ñ–∏–ª—å: ${nickname}`;
            profileHighScoreElement.textContent = profileData.highScore;
            profileGamesPlayedElement.textContent = profileData.gamesPlayed;
            
            
            editProfileButton.style.display = 'none';
            if (currentUser && currentUser.uid === currentProfileUserId) {
                editProfileButton.style.display = 'block';
            }
            
            profileMessage.textContent = '';
            hideEditProfile(); 
            profileModal.style.display = 'block';
        }
        
        function showEditProfile() {
            isEditProfile = true;
            editProfileForm.style.display = 'block';
            editProfileButton.style.display = 'none';
            
            editNicknameInput.value = profileNicknameElement.textContent.replace('–ü—Ä–æ—Ñ–∏–ª—å: ', '');
        }

        function hideEditProfile() {
            isEditProfile = false;
            editProfileForm.style.display = 'none';
            if (currentUser && currentUser.uid === currentProfileUserId) {
                editProfileButton.style.display = 'block';
            }
            profileMessage.textContent = '';
        }

        async function handleProfileEdit(event) {
            event.preventDefault();
            profileMessage.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...';
            
            const newNickname = editNicknameInput.value.trim();
            
            if (!currentUser || currentUser.uid !== currentProfileUserId) {
                profileMessage.textContent = '–û—à–∏–±–∫–∞: –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –ø—Ä–æ—Ñ–∏–ª—å.';
                return;
            }

            if (newNickname.length < 3) {
                profileMessage.textContent = '–ù–∏–∫–Ω–µ–π–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 3 —Å–∏–º–≤–æ–ª–æ–≤.';
                return;
            }
            
            
            const isUnique = await isNicknameUnique(newNickname, currentUser.uid);
            if (!isUnique) {
                profileMessage.textContent = '–û—à–∏–±–∫–∞: –ù–∏–∫–Ω–µ–π–º —É–∂–µ –∑–∞–Ω—è—Ç. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π.';
                return;
            }

            
            const userRef = db.collection("users").doc(currentUser.uid);
            try {
                await userRef.update({ nickname: newNickname });
                await currentUser.updateProfile({ displayName: newNickname });
                
                profileMessage.textContent = '–ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!';
                
                profileNicknameElement.textContent = `–ü—Ä–æ—Ñ–∏–ª—å: ${newNickname}`;
                
                
                authButton.textContent = `–ü—Ä–æ—Ñ–∏–ª—å (${newNickname})`;
                
                hideEditProfile();
                
            } catch (error) {
                profileMessage.textContent = `–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ${error.message}`;
                console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:", error);
            }
        }
        
        
        
        function selectMode(newMode) {
             if (newMode === AI_ONLY_MODE && gameMode === AI_ONLY_MODE) return; 

             gameMode = newMode;
             modeModal.style.display = 'none';
             initializeGame(newMode);
        }
        
        function updateThemeButton(isDark) {
            themeToggleButton.textContent = isDark ? '–°–º–µ–Ω–∏—Ç—å –¢–µ–º—É (–¢–µ–∫—É—â–∞—è: –¢–µ–º–Ω–∞—è)' : '–°–º–µ–Ω–∏—Ç—å –¢–µ–º—É (–¢–µ–∫—É—â–∞—è: –°–≤–µ—Ç–ª–∞—è)';
        }
        
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            
            if (isDark) {
                localStorage.setItem('theme', 'dark');
            } else {
                localStorage.setItem('theme', 'light');
            }
            
            updateThemeButton(isDark);
        }
        
        function selectDifficulty(difficulty) {
            aiDifficulty = difficulty;
            localStorage.setItem('aiDifficulty', difficulty);
            
            difficultyButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-selection-button[data-difficulty="${difficulty}"]`).classList.add('active');
        }

        
        function main() {
             
            const savedDifficulty = localStorage.getItem('aiDifficulty');
            if (savedDifficulty) {
                aiDifficulty = parseInt(savedDifficulty);
                selectDifficulty(aiDifficulty); 
            } else {
                 
                 selectDifficulty(aiDifficulty); 
            }
            
            
            resetButton.onclick = () => initializeGame(gameMode);
            modeButton.onclick = () => modeModal.style.display = 'block';
            settingsButton.onclick = () => settingsModal.style.display = 'block';
            leaderboardButton.onclick = () => {
                 loadLeaderboard();
                 leaderboardModal.style.display = 'block';
            };
            
            
            gameBoardElement.ondragover = handleDragOver;
            gameBoardElement.ondragenter = handleDragEnter;
            gameBoardElement.ondragleave = handleDragLeave;
            gameBoardElement.ondrop = handleDrop;
            
            
            authForm.onsubmit = handleAuthSubmit;
            toggleRegisterButton.onclick = () => {
                isRegistering = !isRegistering;
                document.getElementById('auth-submit').textContent = isRegistering ? '–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è' : '–í–æ–π—Ç–∏';
                toggleRegisterButton.textContent = isRegistering ? '–£–∂–µ –µ—Å—Ç—å –∞–∫–∫–∞—É–Ω—Ç? –í–æ–π—Ç–∏' : '–°–æ–∑–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç';
            };
            
            
            editProfileButton.onclick = showEditProfile;
            cancelEditButton.onclick = hideEditProfile;
            editProfileForm.onsubmit = handleProfileEdit;

            
            closeButtons.forEach(btn => {
                btn.onclick = (e) => {
                    const modalType = e.target.dataset.modal;
                    if (modalType === 'settings') settingsModal.style.display = 'none';
                    if (modalType === 'mode') modeModal.style.display = 'none';
                    if (modalType === 'auth') authModal.style.display = 'none';
                    if (modalType === 'leaderboard') leaderboardModal.style.display = 'none';
                    if (modalType === 'profile') profileModal.style.display = 'none';
                };
            });
            
            
            authButton.onclick = () => {
                if (currentUser) {
                    showProfileModal(currentUser.uid); 
                } else {
                    authModal.style.display = 'block';
                }
            };

            
            modeSelectionButtons.forEach(btn => {
                btn.onclick = (e) => selectMode(e.currentTarget.dataset.mode);
            });
            
            
            difficultyButtons.forEach(btn => {
                 btn.onclick = (e) => selectDifficulty(parseInt(e.currentTarget.dataset.difficulty));
            });

            
            const isDarkMode = localStorage.getItem('theme') === 'dark';
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
            }
            updateThemeButton(isDarkMode); 
            
            
            if (themeToggleButton) {
                themeToggleButton.onclick = toggleTheme;
            }
            
            
            initializeGame(NORMAL_MODE);
        }
        
        main(); 
    </script>
</body>
</html>
