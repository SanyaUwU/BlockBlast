<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BLOCK BLAST Adventure Master</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    
    <style>
        /* Анимация градиента */
        @keyframes background-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Общие стили */
        body {
            font-family: 'Poppins', sans-serif; 
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 30px;
            transition: background-color 0.3s, color 0.3s;
            /* Яркий анимированный градиент */
            background: linear-gradient(-45deg, #4a42f5, #6c5ce7, #a29bfe, #4a42f5);
            background-size: 400% 400%;
            animation: background-animation 20s ease infinite;
            color: #ecf0f1;
        }

        .game-container {
            background-color: #ffffff;
            padding: 25px;
            border-radius: 15px; 
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); 
            text-align: center;
            max-width: 380px;
            transition: background-color 0.3s, box-shadow 0.3s;
            width: 100%;
        }
        
        /* Темная тема */
        body.dark-mode {
            color: #ecf0f1;
            background: linear-gradient(-45deg, #1e1e2f, #3a3a5a, #1e1e2f, #3a3a5a);
            background-size: 400% 400%;
            animation: background-animation 20s ease infinite;
        }
        
        body.dark-mode .game-container {
            background-color: #2c3e50;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5); 
        }
        
        body.dark-mode h1 {
            color: #ffeaa7;
        }
        
        body.dark-mode .score-panel, body.dark-mode #mode-info {
            color: #ecf0f1;
        }

        h1 {
            font-weight: 700;
            color: #ff6b6b; 
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
            transition: color 0.3s;
            margin-top: 0;
            margin-bottom: 15px;
        }

        /* Комбо дисплей */
        #combo-display {
            font-weight: 700;
            text-shadow: 0 0 8px rgba(255, 165, 0, 0.8);
            letter-spacing: 1px;
            transition: opacity 0.5s;
            color: #e67e22;
            font-size: 1.1em;
            opacity: 0;
            min-height: 1.2em;
        }
        
        /* Стили для панели счета */
        .score-panel {
            font-size: 1.3em;
            margin-bottom: 20px;
            font-weight: 600;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #mode-info {
            font-size: 0.9em;
            font-weight: 400;
            margin-top: 5px;
            min-height: 1.1em;
            color: #7f8c8d;
        }

        /* Кнопки в шапке */
        .header-buttons {
            display: flex;
            justify-content: space-between;
            gap: 5px; 
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        /* Сетка */
        #game-board {
            width: 320px; /* 8 * 40px */
            height: 320px; /* 8 * 40px */
            display: grid;
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr);   
            border: 6px solid #ff9f43; 
            border-radius: 8px; 
            background-color: #dfe6e9;
            margin: 0 auto 25px auto;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            transition: border-color 0.3s, background-color 0.3s;
        }
        
        body.dark-mode #game-board {
            background-color: #34495e;
            border-color: #2ecc71;
        }

        .cell {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border: 1px solid #b2bec3; 
            transition: background-color 0.1s, opacity 0.1s, transform 0.1s;
        }
        
        body.dark-mode .cell {
            border: 1px solid #7f8c8d;
        }
        
        .filled {
            border: none;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); 
            opacity: 1 !important;
        }
        
        /* === ИИ-Подсказка: СВЕТЯЩАЯСЯ рамка === */
        .ai-highlight-0 { 
            box-shadow: 0 0 8px 3px #1dd1a1 !important;
            border: 2px solid #1dd1a1 !important;
        }
        .ai-highlight-1 { 
            box-shadow: 0 0 8px 3px #54a0ff !important;
            border: 2px solid #54a0ff !important;
        }
        .ai-highlight-2 { 
            box-shadow: 0 0 8px 3px #ff9f43 !important;
            border: 2px solid #ff9f43 !important;
        }
        
        /* Радужная Анимация исчезновения */
        .clearing {
            animation: rainbow-fade 0.4s ease-in-out forwards;
        }

        @keyframes rainbow-fade {
            0% { background-color: #ff0084; transform: scale(1); opacity: 1; }
            50% { background-color: #3300ff; }
            100% { background-color: #00ff00; transform: scale(0); opacity: 0; }
        }

        /* Панель Фигур */
        .next-blocks-panel {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #f8f8f8;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.05);
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        body.dark-mode .next-blocks-panel {
            background-color: #34495e;
            border-color: #5d6d7e;
        }

        #next-blocks {
            display: flex;
            justify-content: space-around;
            align-items: center; 
            padding: 10px 0;
            min-height: 100px;
        }

        .shape-container {
            width: 80px;
            height: 80px;
            display: flex; 
            justify-content: center;
            align-items: center;
            cursor: grab; 
            background: none; 
            box-shadow: none;
            border-radius: 8px;
            transition: box-shadow 0.2s, opacity 0.2s;
        }
        
        .shape-container.is-dragging {
             opacity: 0.01;
             box-shadow: none;
        }
        
        /* Подсветка фигуры, когда она является целью ИИ */
        .shape-container.ai-target-0 { box-shadow: 0 0 0 3px #1dd1a1; }
        .shape-container.ai-target-1 { box-shadow: 0 0 0 3px #54a0ff; }
        .shape-container.ai-target-2 { box-shadow: 0 0 0 3px #ff9f43; }
        
        .shape-container[draggable="true"]:hover {
             box-shadow: 0 0 0 2px #6c5ce7;
        }
        
        .shape {
            display: grid;
        }

        .block {
            width: 25px;
            height: 25px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
        }
        
        body.dark-mode .block {
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* === ГРАДИЕНТНЫЕ КНОПКИ === */
        .game-button {
            padding: 10px 10px;
            flex-grow: 1;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 8px; 
            font-weight: 600;
            transition: all 0.2s;
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-size: 200% auto;
        }
        
        .game-button:hover {
            background-position: right center;
        }
        
        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .button-primary {
            background-image: linear-gradient(to right, #4a42f5 0%, #6c5ce7 100%);
        }
        
        .button-secondary {
            background-image: linear-gradient(to right, #2ecc71 0%, #27ae60 100%);
        }
        
        .button-danger {
            background-image: linear-gradient(to right, #e74c3c 0%, #c0392b 100%);
        }
        
        .button-settings {
            background-image: linear-gradient(to right, #f39c12 0%, #d35400 100%);
        }
        
        /* Модальные окна */
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            color: #333;
            text-align: left;
        }
        
        body.dark-mode .modal-content {
            background-color: #34495e;
            color: #ecf0f1;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            transition: color 0.2s;
        }

        .close-button:hover,
        .close-button:focus {
            color: #e74c3c;
            text-decoration: none;
            cursor: pointer;
        }
        
        .modal-content h2 {
            margin-top: 0;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: #4a42f5;
        }
        
        body.dark-mode .modal-content h2 {
            color: #2ecc71;
            border-bottom: 2px solid #5d6d7e;
        }
        
        /* Стили формы */
        .auth-form input[type="email"], 
        .auth-form input[type="password"],
        .edit-profile-form input[type="text"] {
            width: 100%;
            padding: 12px;
            margin: 8px 0 15px 0;
            display: inline-block;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
        }
        
        body.dark-mode .auth-form input,
        body.dark-mode .edit-profile-form input {
            background-color: #2c3e50;
            border: 1px solid #5d6d7e;
            color: #ecf0f1;
        }
        
        .auth-form button, 
        .edit-profile-form button {
            margin-top: 10px;
        }
        
        /* Стили таблицы лидеров */
        #leaderboard-list {
            list-style: none;
            padding: 0;
        }
        
        #leaderboard-list li {
            padding: 10px 0;
            border-bottom: 1px dashed #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        body.dark-mode #leaderboard-list li {
            border-bottom: 1px dashed #5d6d7e;
        }
        
        #leaderboard-list li:last-child {
            border-bottom: none;
        }
        
        #leaderboard-list li strong {
            color: #ff9f43;
            min-width: 30px;
            text-align: center;
        }
        
        #leaderboard-list li span {
            font-weight: 600;
            color: #6c5ce7;
        }
        
        body.dark-mode #leaderboard-list li span {
            color: #2ecc71;
        }
        
        /* Стили выбора режима */
        .mode-selection-button {
            display: block;
            padding: 15px;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-align: left;
            border: 2px solid transparent;
            background-color: #ecf0f1;
            color: #333;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            background-image: linear-gradient(to right, #ffeaa7 0%, #fdcb6e 100%);
            background-size: 200% auto;
            color: #333;
        }
        
        .mode-selection-button.active {
            border-color: #6c5ce7;
            background-image: linear-gradient(to right, #a29bfe 0%, #6c5ce7 100%);
            color: white;
            box-shadow: 0 0 15px rgba(108, 92, 231, 0.5);
        }
        
        body.dark-mode .mode-selection-button:not(.active) {
            background-image: linear-gradient(to right, #5d6d7e 0%, #4a5d6e 100%);
            color: #ecf0f1;
        }

        /* === КРЕДИТЫ / КОПИРАЙТА === */
        .sanwec-credit {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 1.2em;
            text-align: center;
            margin-top: 30px;
            background: linear-gradient(45deg, #ff0084, #3300ff, #00ff00, #ff0084);
            background-size: 400% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: text-flow 4s linear infinite;
        }
        @keyframes text-flow {
            to { background-position: 400% center; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>BLOCK BLAST</h1>
        <div class="header-buttons">
            <button id="auth-button" class="game-button button-primary" data-modal="auth">Вход/Регистрация</button>
            <button id="leaderboard-button" class="game-button button-secondary" data-modal="leaderboard">Топ 10</button>
            <button id="mode-button" class="game-button button-settings" data-modal="mode">Режим</button>
            <button id="theme-toggle-button" class="game-button button-settings" data-modal="settings">Светлая тема</button>
        </div>
        
        <div class="score-panel">
            <span>Счет: <span id="score-value">0</span></span>
            <span>Рекорд: <span id="high-score-value">0</span></span>
        </div>
        <div id="combo-display"></div>
        <div id="mode-info"></div>

        <div id="game-board">
            </div>

        <div id="ai-hint-message" style="color: #4a42f5; font-weight: 600; margin-top: 10px; min-height: 1.2em; transition: opacity 0.3s;"></div>
        
        <div class="next-blocks-panel">
            <div id="next-blocks">
                </div>
        </div>
        
        <button id="new-game-button" class="game-button button-danger" style="margin-top: 20px;">Новая игра</button>
        
        <div class="sanwec-credit">
            © 2024 BLOCK BLAST
        </div>
    </div>
    
    <div id="auth-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="auth">&times;</span>
            <h2>Вход / Регистрация</h2>
            <form id="auth-form" class="auth-form">
                <input type="email" id="auth-email" placeholder="Email" required>
                <input type="password" id="auth-password" placeholder="Пароль" required>
                <button type="submit" id="auth-login-button" class="game-button button-primary" style="width: 100%;">Войти</button>
                <button type="button" id="auth-toggle-button" class="game-button button-secondary" style="width: 100%; margin-top: 5px;">Нет аккаунта? Регистрация</button>
            </form>
            <p id="auth-message" style="color: #e74c3c; margin-top: 10px;"></p>
            <div style="margin-top: 15px; text-align: center;">
                <button id="logout-button" class="game-button button-danger" style="width: 100%; display: none;">Выйти</button>
            </div>
        </div>
    </div>
    
    <div id="leaderboard-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="leaderboard">&times;</span>
            <h2>Таблица лидеров</h2>
            <ul id="leaderboard-list">
                </ul>
        </div>
    </div>
    
    <div id="mode-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="mode">&times;</span>
            <h2>Выбор режима игры</h2>
            <button class="mode-selection-button" data-mode="normal">
                <strong>Обычный (Classic)</strong><br>
                <span>Классическая игра на выживание.</span>
            </button>
            <button class="mode-selection-button" data-mode="training">
                <strong>Тренировка (AI Hint)</strong><br>
                <span>ИИ показывает свой лучший ход. Идеально для обучения.</span>
            </button>
        </div>
    </div>
    
    <div id="profile-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="profile">&times;</span>
            <h2>Профиль игрока</h2>
            <p id="profile-nickname">Никнейм: Загрузка...</p>
            <p id="profile-email">Email: Загрузка...</p>
            <p id="profile-high-score">Рекорд: 0</p>
            
            <button id="edit-profile-button" class="game-button button-primary" style="width: 100%; margin-top: 15px; display: none;">Редактировать никнейм</button>
            
            <form id="edit-profile-form" class="edit-profile-form" style="display: none; margin-top: 15px;">
                <label for="edit-nickname-input" style="display: block; margin-top: 15px; margin-bottom: 5px;">Новый никнейм:</label>
                <input type="text" id="edit-nickname-input" placeholder="Введите никнейм" required minlength="3">
                <button type="submit" class="game-button button-secondary" style="width: 100%;">Сохранить</button>
                <button type="button" id="cancel-edit-button" class="game-button button-danger" style="width: 100%; margin-top: 5px;">Отмена</button>
            </form>
            <p id="profile-message" style="color: #e74c3c; margin-top: 10px;"></p>
        </div>
    </div>

    <script>
        // Конфигурация Firebase (замените на свои ключи)
        const firebaseConfig = {
          apiKey: "AIzaSyCZDfxdQ7VGTZEw-LeysLeE7tOAmhT3iwQ",
          authDomain: "block-blast-leader.firebaseapp.com",
          projectId: "block-blast-leader",
          storageBucket: "block-blast-leader.firebasestorage.app",
          messagingSenderId: "435353232888",
          appId: "1:435353232888:web:79480b0345c0209e8d220d",
          measurementId: "G-ZKCKX6NBKZ"
        };

        
        // Инициализация Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // --- КОНСТАНТЫ ИГРЫ ---
        const BOARD_SIZE = 8;
        const EMPTY_COLOR = '';
        const NORMAL_MODE = 'normal';
        const TRAINING_MODE = 'training';
        
        // --- ИИ КОНСТАНТЫ (Модификация для приоритета комбо) ---
        // Устанавливаем высокий приоритет для очистки линий (комбо)
        const AI_COMBO_WEIGHT = 5000; // УВЕЛИЧЕННЫЙ ВЕС: 1 линия=5000, 2 линии=20000, 3 линии=45000...
        const AI_COVERAGE_WEIGHT = 0.5;
        const AI_OCCUPIED_PENALTY = 5;
        
        // --- СОХРАНЕНИЕ СЕССИИ ---
        const SESSION_KEY = 'blockBlastSession';

        // --- ПЕРЕМЕННЫЕ СОСТОЯНИЯ ---
        let board = [];
        let score = 0;
        let highScore = 0;
        let currentShapes = [];
        let draggedShapeIndex = -1;
        let dragOffset = { row: 0, col: 0 };
        let currentUser = null;
        let gameMode = NORMAL_MODE;
        let comboCount = 0;
        let currentProfileUserId = null; // ID пользователя, чей профиль просматривается
        let currentBestPlacements = []; // Результаты ИИ
        
        // --- DOM ЭЛЕМЕНТЫ ---
        const gameBoardElement = document.getElementById('game-board');
        const scoreValueElement = document.getElementById('score-value');
        const highScoreValueElement = document.getElementById('high-score-value');
        const nextBlocksElement = document.getElementById('next-blocks');
        const comboDisplay = document.getElementById('combo-display');
        const modeInfoElement = document.getElementById('mode-info');
        const authButton = document.getElementById('auth-button');
        const authModal = document.getElementById('auth-modal');
        const authForm = document.getElementById('auth-form');
        const authMessage = document.getElementById('auth-message');
        const authToggleButton = document.getElementById('auth-toggle-button');
        const logoutButton = document.getElementById('logout-button');
        const leaderboardModal = document.getElementById('leaderboard-modal');
        const leaderboardList = document.getElementById('leaderboard-list');
        const modeModal = document.getElementById('mode-modal');
        const modeSelectionButtons = document.querySelectorAll('.mode-selection-button');
        const profileModal = document.getElementById('profile-modal');
        const profileNicknameElement = document.getElementById('profile-nickname');
        const profileEmailElement = document.getElementById('profile-email');
        const profileHighScoreElement = document.getElementById('profile-high-score');
        const editProfileButton = document.getElementById('edit-profile-button');
        const editProfileForm = document.getElementById('edit-profile-form');
        const editNicknameInput = document.getElementById('edit-nickname-input');
        const profileMessage = document.getElementById('profile-message');
        const cancelEditButton = document.getElementById('cancel-edit-button');
        const newGameButton = document.getElementById('new-game-button');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        
        // Все кнопки закрытия модальных окон
        const closeButtons = document.querySelectorAll('.close-button');

        // --- ФИГУРЫ ---
        const SHAPES = [
            // 1x1
            { size: 1, color: '#feca57', pattern: [[1]] },
            // 1x2, 2x1
            { size: 2, color: '#feca57', pattern: [[1,1]] },
            { size: 2, color: '#feca57', pattern: [[1],[1]] },
            // 2x2 квадрат, 1x3, 3x1 (базовые)
            { size: 4, color: '#54a0ff', pattern: [[1,1],[1,1]] },
            { size: 3, color: '#1dd1a1', pattern: [[1,1,1]] },
            { size: 3, color: '#1dd1a1', pattern: [[1],[1],[1]] },
            // 1x4, 4x1
            { size: 4, color: '#ff6b6b', pattern: [[1,1,1,1]] },
            { size: 4, color: '#ff6b6b', pattern: [[1],[1],[1],[1]] },
            // 2x3 L-образные
            { size: 3, color: '#a29bfe', pattern: [[1,0],[1,1]] }, // L
            { size: 3, color: '#a29bfe', pattern: [[0,1],[1,1]] },
            { size: 3, color: '#a29bfe', pattern: [[1,1],[1,0]] },
            { size: 3, color: '#a29bfe', pattern: [[1,1],[0,1]] },
            // 2x2 T-образная
            { size: 3, color: '#ff9f43', pattern: [[0,1,0],[1,1,1]] }, // T
            // 3x3 L-образная
            { size: 5, color: '#1abc9c', pattern: [[1,0,0],[1,0,0],[1,1,1]] }, // Большая L
            { size: 5, color: '#1abc9c', pattern: [[1,1,1],[1,0,0],[1,0,0]] },
            // 3x3 T-образная
            { size: 5, color: '#9b59b6', pattern: [[1,1,1],[0,1,0],[0,1,0]] },
            // 3x3 квадрат
            { size: 9, color: '#f1c40f', pattern: [[1,1,1],[1,1,1],[1,1,1]] },
        ];
        
        // --- ФУНКЦИИ УПРАВЛЕНИЯ ИГРОЙ И СЕССИЕЙ ---
        
        function updateModeInfo(mode) {
            if (mode === TRAINING_MODE) {
                modeInfoElement.textContent = "Режим: Тренировка (ИИ подсказывает лучший ход)";
                document.getElementById('ai-hint-message').style.opacity = 1;
            } else {
                modeInfoElement.textContent = "Режим: Обычный";
                document.getElementById('ai-hint-message').style.opacity = 0;
            }
        }

        function initializeGame(mode) {
            clearGameSession(); // Очищаем старую сессию при начале новой игры
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(EMPTY_COLOR));
            score = 0;
            comboCount = 0;
            gameMode = mode;
            currentBestPlacements = [];
            
            scoreValueElement.textContent = score;
            comboDisplay.style.opacity = 0;
            
            updateModeInfo(mode);
            drawBoard();
            generateNextShapes();
            renderNextBlocks();
            clearHighlights();
        }
        
        // --- ФУНКЦИИ СОХРАНЕНИЯ/ЗАГРУЗКИ СЕССИИ (LocalStorage) ---

        function saveGameSession() {
            if (gameMode !== NORMAL_MODE && gameMode !== TRAINING_MODE) return; 
            
            const sessionData = {
                board: board.map(row => [...row]), 
                score: score,
                comboCount: comboCount,
                gameMode: gameMode,
                currentShapes: currentShapes.map(s => s ? { ...s, pattern: s.pattern.map(row => [...row]) } : null) 
            };
            
            localStorage.setItem(SESSION_KEY, JSON.stringify(sessionData));
            console.log("Состояние игры сохранено.");
        }

        function clearGameSession() {
            localStorage.removeItem(SESSION_KEY);
            console.log("Состояние игры очищено.");
        }

        function loadGameSession() {
            const sessionDataString = localStorage.getItem(SESSION_KEY);
            if (!sessionDataString) return false;
            
            try {
                const sessionData = JSON.parse(sessionDataString);
                
                // Восстановление основных переменных
                board = sessionData.board;
                score = sessionData.score;
                comboCount = sessionData.comboCount;
                gameMode = sessionData.gameMode;
                
                // Важно: нужно восстановить объекты фигур из SHAPES, 
                // так как pattern в сессии - это просто копия, а не ссылка.
                currentShapes = sessionData.currentShapes.map(savedShape => {
                    if (!savedShape) return null;
                    // Находим оригинальную фигуру по размеру и паттерну
                    return SHAPES.find(s => 
                        s.size === savedShape.size && 
                        s.color === savedShape.color && 
                        JSON.stringify(s.pattern) === JSON.stringify(savedShape.pattern)
                    ) || savedShape; // Если не нашли, используем сохраненный
                });
                
                // Обновление UI
                document.getElementById('score-value').textContent = score;
                updateModeInfo(gameMode);
                drawBoard();
                renderNextBlocks();
                
                // Проверка на конец игры после загрузки (на всякий случай)
                // checkGameOver(); // Лучше не вызывать, чтобы не проиграть сразу после загрузки
                
                console.log("Состояние игры загружено.");
                return true;
            } catch (e) {
                console.error("Ошибка при загрузке сессии:", e);
                clearGameSession(); // Очистить поврежденную сессию
                return false;
            }
        }

        // --- ФУНКЦИИ СЕТКИ И РИСОВАНИЯ ---

        function drawBoard() {
            gameBoardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    if (board[r][c] !== EMPTY_COLOR) {
                        cell.classList.add('filled');
                        cell.style.backgroundColor = board[r][c];
                    }
                    gameBoardElement.appendChild(cell);
                }
            }
        }
        
        function generateNextShapes() {
            // ВСЕГДА генерируем 3 фигуры
            currentShapes = [];
            for (let i = 0; i < 3; i++) {
                const randomIndex = Math.floor(Math.random() * SHAPES.length);
                currentShapes.push(SHAPES[randomIndex]);
            }
            if (gameMode === TRAINING_MODE) {
                calculateBestMoves();
            }
        }

        function createShapeElement(shapeData, index) {
            const shapeContainer = document.createElement('div');
            shapeContainer.classList.add('shape-container');
            shapeContainer.dataset.shapeIndex = index;
            
            if (shapeData) {
                shapeContainer.setAttribute('draggable', true);
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape');
                shapeDiv.style.gridTemplateColumns = `repeat(${shapeData.pattern[0].length}, 1fr)`;
                
                shapeData.pattern.forEach(row => {
                    row.forEach(cell => {
                        const block = document.createElement('div');
                        block.classList.add('block');
                        if (cell === 1) {
                            block.style.backgroundColor = shapeData.color;
                            block.classList.add('filled');
                        }
                        shapeDiv.appendChild(block);
                    });
                });
                shapeContainer.appendChild(shapeDiv);
            }
            return shapeContainer;
        }

        function renderNextBlocks() {
            nextBlocksElement.innerHTML = '';
            let blocksRemaining = false;
            
            currentShapes.forEach((shapeData, index) => {
                const shapeContainer = createShapeElement(shapeData, index);
                nextBlocksElement.appendChild(shapeContainer);
                if (shapeData) {
                    blocksRemaining = true;
                    // Добавление обработчиков Drag & Drop
                    shapeContainer.addEventListener('dragstart', handleDragStart);
                    shapeContainer.addEventListener('dragend', handleDragEnd);
                }
            });
            
            if (!blocksRemaining) {
                generateNextShapes();
            }
            
            // Сброс и применение подсказок ИИ после рендера
            clearHighlights();
            if (gameMode === TRAINING_MODE) {
                highlightAIBestMoves();
            }
        }
        
        // --- ЛОГИКА ИГРЫ ---

        function canPlaceShape(pattern, startRow, startCol, currentBoard = board) {
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        const boardR = startRow + r;
                        const boardC = startCol + c;
                        
                        // Проверка границ
                        if (boardR < 0 || boardR >= BOARD_SIZE || boardC < 0 || boardC >= BOARD_SIZE) {
                            return false;
                        }
                        // Проверка наложения (если ячейка занята)
                        if (currentBoard[boardR][boardC] !== EMPTY_COLOR) {
                            return false; 
                        }
                    }
                }
            }
            return true;
        }

        function placeShape(shapeData, startRow, startCol) {
            const pattern = shapeData.pattern;
            
            if (!canPlaceShape(pattern, startRow, startCol)) {
                return false;
            }

            // Размещение
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        board[startRow + r][startCol + c] = shapeData.color;
                    }
                }
            }
            
            score += shapeData.size;
            scoreValueElement.textContent = score;
            drawBoard();
            
            // Удаление фигуры из списка
            currentShapes[draggedShapeIndex] = null;
            
            renderNextBlocks();
            checkClearsAndUpdateScore();
            checkGameOver();
            
            saveGameSession(); // Сохраняем сессию после хода
            
            return true;
        }
        
        function checkClears(currentBoard) {
            let clearedLines = 0;
            let cellsToClear = new Set();
            
            // Проверка строк
            for (let r = 0; r < BOARD_SIZE; r++) {
                let isRowFull = true;
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] === EMPTY_COLOR) {
                        isRowFull = false;
                        break;
                    }
                }
                if (isRowFull) {
                    clearedLines++;
                    for (let c = 0; c < BOARD_SIZE; c++) cellsToClear.add(`${r}-${c}`);
                }
            }

            // Проверка столбцов
            for (let c = 0; c < BOARD_SIZE; c++) {
                let isColFull = true;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    if (currentBoard[r][c] === EMPTY_COLOR) {
                        isColFull = false;
                        break;
                    }
                }
                if (isColFull) {
                    clearedLines++;
                    for (let r = 0; r < BOARD_SIZE; r++) cellsToClear.add(`${r}-${c}`);
                }
            }
            
            return { clearedLines, cellsToClear };
        }

        function checkClearsAndUpdateScore() {
            const { clearedLines, cellsToClear } = checkClears(board);
            
            if (clearedLines > 0) {
                // Комбо-логика
                if (clearedLines > 1) {
                    comboCount++;
                } else {
                    comboCount = 0;
                }
                
                // Бонус за очистку
                let bonusScore = 0;
                if (comboCount > 0) {
                    // Экспоненциальный рост бонуса за комбо
                    bonusScore = clearedLines * clearedLines * 100 * comboCount; 
                    comboDisplay.textContent = `КОМБО x${comboCount}! (+${bonusScore} очков)`;
                    comboDisplay.style.opacity = 1;
                } else {
                    bonusScore = clearedLines * 100;
                    comboDisplay.textContent = `+${bonusScore} очков за ${clearedLines} линий!`;
                    comboDisplay.style.opacity = 1;
                }
                
                score += bonusScore;
                scoreValueElement.textContent = score;

                // Анимация очистки
                cellsToClear.forEach(key => {
                    const [r, c] = key.split('-').map(Number);
                    const cell = gameBoardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.add('clearing');
                    }
                });

                // Ждем окончания анимации, затем очищаем
                setTimeout(() => {
                    cellsToClear.forEach(key => {
                        const [r, c] = key.split('-').map(Number);
                        board[r][c] = EMPTY_COLOR;
                    });
                    
                    drawBoard();
                    
                    // Скрываем комбо-сообщение
                    setTimeout(() => {
                        comboDisplay.style.opacity = 0;
                    }, 500);

                    // Пересчитываем ИИ-ходы после очистки
                    if (gameMode === TRAINING_MODE) {
                         calculateBestMoves();
                         highlightAIBestMoves();
                    }
                    
                }, 400); // 400ms - продолжительность анимации clearing
            } else {
                comboCount = 0;
                comboDisplay.style.opacity = 0;
            }
        }

        function checkGameOver() {
            const remainingShapes = currentShapes.filter(s => s !== null);
            
            if (remainingShapes.length > 0) {
                let canPlaceAny = false;
                for (const shapeData of remainingShapes) {
                    if (shapeData) {
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE; c++) {
                                // Проверка возможности размещения в любой точке
                                if (canPlaceShape(shapeData.pattern, r, c)) {
                                    canPlaceAny = true;
                                    break;
                                }
                            }
                            if (canPlaceAny) break;
                        }
                    }
                    if (canPlaceAny) break;
                }
                
                if (!canPlaceAny) {
                    endGame();
                }
            }
        }

        async function endGame() {
            if (score > highScore) {
                highScore = score;
                highScoreValueElement.textContent = highScore;
                
                if (currentUser) {
                    await updateHighScore(highScore);
                }
            }
            
            // Визуальное уведомление о конце игры
            setTimeout(() => {
                alert(`Игра окончена! Ваш финальный счет: ${score}`);
                initializeGame(gameMode); // Начать новую игру
            }, 500);
        }
        
        // --- ФУНКЦИИ ИИ (AI) ---

        function calculateHeuristicScore(boardState, shapeData, startRow, startCol) {
            const pattern = shapeData.pattern;
            let tempCells = boardState.map(row => [...row]); 

            // 1. Проверка наложения (Цель: ИИ не расставляет фигуры друг в друга)
            if (!canPlaceShape(pattern, startRow, startCol, tempCells)) {
                 return -Infinity; 
            }

            // 2. Симуляция размещения 
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        tempCells[startRow + r][startCol + c] = shapeData.color;
                    }
                }
            }

            // 3. Расчет очистки (для симулированной доски)
            const { clearedLines } = checkClears(tempCells); 

            let score = 0;
            
            // --- Усиление Combo-логики (Цель: ИИ должен стараться делать комбо) ---
            if (clearedLines > 0) {
                // Экспоненциальный бонус за комбо
                score += clearedLines * clearedLines * AI_COMBO_WEIGHT; 
            }
            
            // 4. Штраф за заполненность
            let occupiedCells = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (tempCells[r][c] !== EMPTY_COLOR) {
                        occupiedCells++;
                    }
                }
            }
            score -= occupiedCells * AI_OCCUPIED_PENALTY; 

            return score;
        }

        function calculateBestMoves() {
            currentBestPlacements = [];
            
            currentShapes.forEach((shapeData, shapeIndex) => {
                if (!shapeData) return;
                
                let bestScore = -Infinity;
                let bestPlacement = null;
                
                // Проверяем все возможные позиции (8x8)
                for (let r = 0; r <= BOARD_SIZE - shapeData.pattern.length; r++) {
                    for (let c = 0; c <= BOARD_SIZE - shapeData.pattern[0].length; c++) {
                        
                        const currentScore = calculateHeuristicScore(board, shapeData, r, c);
                        
                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            bestPlacement = { startR: r, startC: c, score: bestScore };
                        }
                    }
                }
                
                // Сохраняем лучший ход
                if (bestPlacement && bestPlacement.score > -Infinity) {
                    currentBestPlacements[shapeIndex] = bestPlacement;
                } else {
                    currentBestPlacements[shapeIndex] = null;
                }
            });
            
            // Если ни одна фигура не может быть размещена, ИИ не показывает подсказку.
            // Но это также означает, что игра окончена.
        }
        
        function clearHighlights() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('ai-highlight-0', 'ai-highlight-1', 'ai-highlight-2');
            });
            document.querySelectorAll('.shape-container').forEach(container => {
                container.classList.remove('ai-target-0', 'ai-target-1', 'ai-target-2');
            });
            document.getElementById('ai-hint-message').textContent = '';
        }

        function highlightAI(placement, shapeData, index) {
            const { startR, startC } = placement;
            const pattern = shapeData.pattern;
            const colorClass = `ai-highlight-${index}`;
            const targetClass = `ai-target-${index}`;
            
            // Подсвечиваем контейнер фигуры
            const shapeContainer = document.querySelector(`.shape-container[data-shape-index="${index}"]`);
            if (shapeContainer) {
                shapeContainer.classList.add(targetClass);
            }
            
            // Подсвечиваем ячейки на доске
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        const boardR = startR + r;
                        const boardC = startC + c;
                        const cell = gameBoardElement.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                        if (cell) {
                            cell.classList.add(colorClass);
                        }
                    }
                }
            }
        }
        
        function highlightAIBestMoves() {
            clearHighlights();
            let hasValidMove = false;
            
            // Находим лучший ход из всех возможных для всех трех фигур
            let bestOverallScore = -Infinity;
            let bestOverallShapeIndex = -1;
            
            currentBestPlacements.forEach((placement, index) => {
                if (placement && placement.score > bestOverallScore) {
                    bestOverallScore = placement.score;
                    bestOverallShapeIndex = index;
                }
            });

            if (bestOverallShapeIndex !== -1 && bestOverallScore > -Infinity) {
                const placement = currentBestPlacements[bestOverallShapeIndex];
                const shapeData = currentShapes[bestOverallShapeIndex];
                highlightAI(placement, shapeData, bestOverallShapeIndex);
                document.getElementById('ai-hint-message').textContent = "Подсказка ИИ: Используй подсвеченную фигуру в подсвеченной области!";
                hasValidMove = true;
            }
            
            if (!hasValidMove) {
                 document.getElementById('ai-hint-message').textContent = "ИИ не нашел подходящего хода. Скоро конец игры.";
            }
        }

        // --- DRAG & DROP ФУНКЦИИ ---

        function handleDragStart(event) {
            const shapeContainer = event.currentTarget;
            draggedShapeIndex = parseInt(shapeContainer.dataset.shapeIndex);
            
            shapeContainer.classList.add('is-dragging');
            event.dataTransfer.setData('text/plain', draggedShapeIndex);
            
            // Расчет смещения: клик относительно верхнего левого угла фигуры
            const shapeRect = shapeContainer.getBoundingClientRect();
            const x = event.clientX - shapeRect.left;
            const y = event.clientY - shapeRect.top;
            
            // Ширина/высота блока в пикселях
            const blockWidth = shapeRect.width / currentShapes[draggedShapeIndex].pattern[0].length;
            const blockHeight = shapeRect.height / currentShapes[draggedShapeIndex].pattern.length;
            
            // Определение, какой блок был нажат (для точного смещения)
            let clickedRow = 0;
            let clickedCol = 0;
            const pattern = currentShapes[draggedShapeIndex].pattern;
            
            for (let r = 0; r < pattern.length; r++) {
                for (let c = 0; c < pattern[0].length; c++) {
                    if (pattern[r][c] === 1) {
                        if (x >= c * blockWidth && x < (c + 1) * blockWidth &&
                            y >= r * blockHeight && y < (r + 1) * blockHeight) {
                            clickedRow = r;
                            clickedCol = c;
                            break;
                        }
                    }
                }
                if (clickedRow !== 0 || clickedCol !== 0) break;
            }

            dragOffset = { row: clickedRow, col: clickedCol };
            
            // Установка "фантомного" изображения (по умолчанию - пустая фигура)
            const dragImage = shapeContainer.cloneNode(true);
            dragImage.style.opacity = '0.5';
            dragImage.style.position = 'absolute';
            dragImage.style.left = '-1000px'; 
            document.body.appendChild(dragImage);
            event.dataTransfer.setDragImage(dragImage, x, y);

            // Удаляем клонированное изображение после dragstart
            setTimeout(() => document.body.removeChild(dragImage), 0);
            
            // Если это режим тренировки, очищаем все, чтобы не мешало
            if (gameMode === TRAINING_MODE) {
                clearHighlights();
            }
        }

        function handleDragEnd(event) {
            const shapeContainer = event.currentTarget;
            shapeContainer.classList.remove('is-dragging');
            draggedShapeIndex = -1;
            
            if (gameMode === TRAINING_MODE) {
                highlightAIBestMoves(); // Восстанавливаем подсказку, если не был сделан ход
            }
        }

        function handleDragOver(event) {
            event.preventDefault(); // Разрешаем drop
            const targetCell = event.target.closest('.cell');
            if (!targetCell || draggedShapeIndex === -1) return;
            
            // Визуальная подсветка потенциального хода
            document.querySelectorAll('.potential-placement').forEach(cell => {
                cell.classList.remove('potential-placement');
            });

            const cellRow = parseInt(targetCell.dataset.row);
            const cellCol = parseInt(targetCell.dataset.col);
            const startRow = cellRow - dragOffset.row;
            const startCol = cellCol - dragOffset.col;
            const shapeData = currentShapes[draggedShapeIndex];
            
            if (!shapeData) return;

            if (canPlaceShape(shapeData.pattern, startRow, startCol)) {
                for (let r = 0; r < shapeData.pattern.length; r++) {
                    for (let c = 0; c < shapeData.pattern[0].length; c++) {
                        if (shapeData.pattern[r][c] === 1) {
                            const boardR = startRow + r;
                            const boardC = startCol + c;
                            const cell = gameBoardElement.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                            if (cell) {
                                cell.classList.add('potential-placement');
                                cell.style.backgroundColor = shapeData.color;
                            }
                        }
                    }
                }
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            const targetCell = event.target.closest('.cell');
            document.querySelectorAll('.potential-placement').forEach(cell => {
                cell.classList.remove('potential-placement');
                cell.style.backgroundColor = ''; // Очистка фона
            });

            if (!targetCell || draggedShapeIndex === -1) return;

            const cellRow = parseInt(targetCell.dataset.row);
            const cellCol = parseInt(targetCell.dataset.col);
            const startRow = cellRow - dragOffset.row;
            const startCol = cellCol - dragOffset.col;
            
            const shapeData = currentShapes[draggedShapeIndex];
            if (!shapeData) return;
            
            // Если фигура успешно размещена, placeShape сделает всю работу
            placeShape(shapeData, startRow, startCol);
        }
        
        // --- ФУНКЦИИ FIREBASE (АУТЕНТИФИКАЦИЯ, СЧЕТ) ---

        auth.onAuthStateChanged(async (user) => {
            currentUser = user;
            if (user) {
                authButton.textContent = `Профиль (${user.displayName || (user.email ? user.email.split('@')[0] : 'Anon')})`;
                logoutButton.style.display = 'block';
                await fetchProfile(user.uid); // Загружаем данные профиля текущего пользователя
                authModal.style.display = 'none';
            } else {
                authButton.textContent = 'Вход/Регистрация';
                logoutButton.style.display = 'none';
                highScore = 0;
                highScoreValueElement.textContent = 0;
            }
        });
        
        // --- ПРОФИЛЬ И РЕКОРД ---

        async function fetchProfile(userId) {
            try {
                const doc = await db.collection("users").doc(userId).get();
                if (doc.exists) {
                    const data = doc.data();
                    highScore = data.highScore || 0;
                    highScoreValueElement.textContent = highScore;
                } else {
                    // Создание базового профиля, если его нет
                    await db.collection("users").doc(userId).set({
                        highScore: 0,
                        email: currentUser.email,
                        nickname: currentUser.displayName || (currentUser.email ? currentUser.email.split('@')[0] : 'Anon')
                    });
                }
            } catch (error) {
                console.error("Ошибка загрузки профиля:", error);
            }
        }

        async function updateHighScore(newScore) {
            if (!currentUser) return;
            try {
                // Обновляем только если новый счет выше
                await db.collection("users").doc(currentUser.uid).set({
                    highScore: newScore
                }, { merge: true });
                console.log("Рекорд обновлен!");
            } catch (error) {
                console.error("Ошибка обновления рекорда:", error);
            }
        }

        async function loadLeaderboard() {
            leaderboardList.innerHTML = '<li>Загрузка...</li>';
            try {
                // Запрашиваем 10 лучших результатов
                const snapshot = await db.collection("users")
                    .orderBy("highScore", "desc")
                    .limit(10)
                    .get();
                
                leaderboardList.innerHTML = ''; 
                let rank = 1;
                
                if (snapshot.empty) {
                    leaderboardList.innerHTML = '<li>Таблица лидеров пуста. Будьте первым!</li>';
                } else {
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const nickname = data.nickname || (data.email ? data.email.split('@')[0] : 'Anon');
                        const li = document.createElement('li');
                        li.innerHTML = `
                            <strong>#${rank}</strong> ${nickname}: <span>${data.highScore} очков</span>
                            <button class="game-button view-profile-button" data-user-id="${doc.id}" style="padding: 5px 10px; font-size: 0.8em; margin-left: 10px; background-image: linear-gradient(to right, #6c5ce7 0%, #a29bfe 100%);">Профиль</button>
                        `;
                        leaderboardList.appendChild(li);
                        rank++;
                    });
                    
                    // Добавляем обработчики кликов на кнопки "Профиль"
                    document.querySelectorAll('.view-profile-button').forEach(button => {
                        button.onclick = (e) => {
                            e.stopPropagation(); 
                            const userId = e.target.dataset.userId;
                            leaderboardModal.style.display = 'none'; 
                            showProfileModal(userId); 
                        };
                    });
                }
            } catch (error) {
                console.error("Ошибка загрузки таблицы лидеров:", error);
                leaderboardList.innerHTML = '<li>Не удалось загрузить таблицу. Проверьте соединение и правила Firestore.</li>';
            }
        }

        async function showProfileModal(userId) {
            currentProfileUserId = userId;
            profileMessage.textContent = 'Загрузка данных...';
            
            // Сброс видимости элементов
            editProfileButton.style.display = 'none';
            editProfileForm.style.display = 'none';

            try {
                const doc = await db.collection("users").doc(userId).get();
                if (!doc.exists) {
                    profileMessage.textContent = 'Ошибка: Профиль не найден.';
                    profileModal.style.display = 'block';
                    return;
                }
                
                const data = doc.data();
                const isCurrentUser = currentUser && currentUser.uid === userId; // Определяем, является ли это текущим пользователем

                profileNicknameElement.textContent = `Никнейм: ${data.nickname || (data.email ? data.email.split('@')[0] : 'Anon')}`;
                
                // --- ЛОГИКА СКРЫТИЯ ПОЧТЫ ---
                if (data.email) {
                    profileEmailElement.textContent = isCurrentUser 
                        ? `Email: ${data.email}` // Показываем полную почту для себя
                        : `Email: Скрыто`; // Скрываем почту для других пользователей
                } else {
                    profileEmailElement.textContent = 'Email: Нет';
                }
                // --- КОНЕЦ ЛОГИКИ СКРЫТИЯ ПОЧТЫ ---
                
                profileHighScoreElement.textContent = `Рекорд: ${data.highScore || 0} очков`;

                // Отображаем кнопку редактирования только для владельца профиля
                if (isCurrentUser) {
                    editProfileButton.style.display = 'block';
                }
                profileMessage.textContent = '';
                profileModal.style.display = 'block';

            } catch (error) {
                console.error("Ошибка при отображении профиля:", error);
                profileMessage.textContent = 'Ошибка загрузки профиля.';
            }
        }
        
        async function handleProfileEdit(event) {
            event.preventDefault();
            profileMessage.textContent = 'Сохранение...';

            const newNickname = editNicknameInput.value.trim();

            if (!currentUser || currentUser.uid !== currentProfileUserId) {
                profileMessage.textContent = 'Ошибка: Вы не можете редактировать этот профиль.';
                return;
            }
            if (newNickname.length < 3 || newNickname.length > 20) {
                profileMessage.textContent = 'Ошибка: Никнейм должен быть от 3 до 20 символов.';
                return;
            }
            
            // 1. Проверка на дубликат никнейма
            try {
                const snapshot = await db.collection("users")
                    .where("nickname", "==", newNickname)
                    .limit(1)
                    .get();

                if (!snapshot.empty) {
                    // Проверяем, не является ли найденный никнейм текущим никнеймом пользователя
                    const docId = snapshot.docs[0].id;
                    if (docId !== currentUser.uid) {
                        profileMessage.textContent = 'Ошибка: Никнейм уже занят другим пользователем.';
                        return;
                    }
                }
            } catch (error) {
                console.error("Ошибка проверки никнейма:", error);
                profileMessage.textContent = 'Ошибка сервера при проверке никнейма.';
                return;
            }
            
            // Получаем текущие данные для сохранения highscore
            let data = {};
            try {
                const doc = await db.collection("users").doc(currentUser.uid).get();
                if (doc.exists) {
                    data = doc.data();
                }
            } catch (error) {
                console.error("Ошибка получения текущих данных профиля:", error);
                profileMessage.textContent = 'Ошибка при получении текущих данных профиля.';
                return;
            }


            // 2. Обновление никнейма в Firebase
            try {
                await db.collection("users").doc(currentUser.uid).set({
                    nickname: newNickname,
                    highScore: data.highScore || 0, // Сохраняем существующий highscore
                    email: currentUser.email 
                }, { merge: true }); 

                await currentUser.updateProfile({
                    displayName: newNickname
                });

                // Обновление UI
                authButton.textContent = `Профиль (${newNickname})`;
                profileNicknameElement.textContent = `Никнейм: ${newNickname}`;
                profileMessage.textContent = 'Никнейм успешно обновлен!';
                
                hideEditProfile();
                loadLeaderboard(); 
            } catch (error) {
                console.error("Ошибка сохранения профиля:", error);
                profileMessage.textContent = `Ошибка сохранения: ${error.message}`;
            }
        }
        
        function hideEditProfile() {
            editProfileButton.style.display = 'block';
            editProfileForm.style.display = 'none';
        }
        
        // --- ОБРАБОТЧИКИ СОБЫТИЙ UI ---

        function handleAuthToggle() {
            const isLogin = authToggleButton.textContent.includes('Регистрация');
            if (isLogin) {
                authToggleButton.textContent = 'Уже есть аккаунт? Вход';
                document.getElementById('auth-login-button').textContent = 'Регистрация';
            } else {
                authToggleButton.textContent = 'Нет аккаунта? Регистрация';
                document.getElementById('auth-login-button').textContent = 'Войти';
            }
        }

        async function handleAuthFormSubmit(event) {
            event.preventDefault();
            authMessage.textContent = '';

            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            const isLogin = authToggleButton.textContent.includes('Регистрация');
            
            try {
                if (isLogin) {
                    // Вход
                    await auth.signInWithEmailAndPassword(email, password);
                } else {
                    // Регистрация
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    const user = userCredential.user;
                    // Устанавливаем базовый никнейм
                    const nickname = email.split('@')[0];
                    await user.updateProfile({
                        displayName: nickname
                    });
                    
                    // Создаем запись в Firestore
                    await db.collection("users").doc(user.uid).set({
                        highScore: 0,
                        email: email,
                        nickname: nickname
                    });

                    authMessage.textContent = 'Регистрация прошла успешно!';
                }
                // AuthStateChanged обновит UI и закроет модальное окно
            } catch (error) {
                console.error("Ошибка аутентификации:", error);
                authMessage.textContent = `Ошибка: ${error.message}`;
            }
        }
        
        function handleLogout() {
            auth.signOut();
            authModal.style.display = 'none';
            profileModal.style.display = 'none';
        }

        function selectMode(mode) {
            modeModal.style.display = 'none';
            if (mode !== gameMode) {
                // Спрашиваем подтверждение, так как сбросится сессия
                if (confirm(`Вы действительно хотите изменить режим на "${mode}"? Ваша текущая игра будет сброшена.`)) {
                     initializeGame(mode);
                }
            }
            
            // Обновляем состояние кнопок режима 
            modeSelectionButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === gameMode) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateThemeButton(isDarkMode) {
            themeToggleButton.textContent = isDarkMode ? 'Темная тема' : 'Светлая тема';
        }

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            updateThemeButton(isDarkMode);
        }

        // --- ИНИЦИАЛИЗАЦИЯ ---

        function main() {
            // Установка обработчиков Drag & Drop на саму доску
            gameBoardElement.addEventListener('dragover', handleDragOver);
            gameBoardElement.addEventListener('drop', handleDrop);
            
            // Обработчики аутентификации
            authToggleButton.onclick = handleAuthToggle;
            authForm.onsubmit = handleAuthFormSubmit;
            logoutButton.onclick = handleLogout;
            
            // Обработчики профиля
            editProfileButton.onclick = () => {
                editProfileButton.style.display = 'none';
                editProfileForm.style.display = 'block';
                editNicknameInput.value = profileNicknameElement.textContent.replace('Никнейм: ', '').trim();
                profileMessage.textContent = '';
            };
            cancelEditButton.onclick = hideEditProfile;
            editProfileForm.onsubmit = handleProfileEdit;

            // Обработчики для закрытия модальных окон
            closeButtons.forEach(btn => {
                btn.onclick = (e) => {
                    const modalType = e.target.dataset.modal;
                    if (modalType === 'mode') modeModal.style.display = 'none';
                    if (modalType === 'auth') authModal.style.display = 'none';
                    if (modalType === 'leaderboard') leaderboardModal.style.display = 'none';
                    if (modalType === 'profile') profileModal.style.display = 'none';
                };
            });
            
            // Клик по профилю в панели входа
            authButton.onclick = () => {
                if (currentUser) {
                    showProfileModal(currentUser.uid); 
                } else {
                    authModal.style.display = 'block';
                }
            };
            
            // Кнопка "Топ 10"
            document.getElementById('leaderboard-button').onclick = () => {
                loadLeaderboard();
                leaderboardModal.style.display = 'block';
            };
            
            // Обработчики для выбора режима
            modeSelectionButtons.forEach(btn => {
                btn.onclick = (e) => selectMode(e.currentTarget.dataset.mode);
            });
            
            // Кнопка "Новая игра"
            newGameButton.onclick = () => {
                if (confirm('Начать новую игру? Текущий прогресс будет потерян.')) {
                    initializeGame(gameMode);
                }
            };

            // Инициализация темной темы
            const isDarkMode = localStorage.getItem('theme') === 'dark';
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
            }
            updateThemeButton(isDarkMode); 
            
            // Обработчик кнопки смены темы
            if (themeToggleButton) {
                themeToggleButton.onclick = toggleTheme;
            }
            
            // --- ЗАПУСК ИГРЫ ---
            // Сначала пытаемся загрузить сессию, иначе начинаем новую.
            if (!loadGameSession()) {
                initializeGame(NORMAL_MODE);
            }
        }
        
        main(); // Запуск основной функции
    </script>
</body>
</html>
